/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jingju_jnitest_Echo */

#ifndef _Included_com_jingju_jnitest_Echo
#define _Included_com_jingju_jnitest_Echo
#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>
#include <stdarg.h>
#include <errno.h>
#include <string.h>

//socket , bind , getsockname,listen,accep,recev,send,connect
#include <sys/types.h>
#include <sys/socket.h>

//sockaddr_un
#include <sys/un.h>

//sockaddr_in
#include <netinet/in.h>

//inet_ntop
#include <arpa//inet.h>

//close , unlink
#include <unistd.h>

//offsetof
#include <stddef.h>


//最大日志消息长度
#define MAX_LOG_MESSAGE_LENGTH 256

//最大数据缓冲区
#define MAX_BUFFER_SIZE 80


/**
 * 将给定的消息记录到应用程序
 * @param env
 * @param obj
 * @param format
 * @param ...
 */
static void LogMessage(JNIEnv *env, jobject obj, const char *format, ...) {

    //缓存日志方法ID
    static jmethodID methodId = nullptr;

    if (nullptr == methodId) {
        //从对象获取类
        jclass clazz = env->GetObjectClass(obj);

        //从给定方法获取Id
        methodId = env->GetMethodID(clazz, "logMessage",
                                    "(Ljava/lang/String;)V");
        env->DeleteGlobalRef(clazz);
    }

    if (nullptr != methodId) {
        //格式化日志消息
        char buffer[MAX_LOG_MESSAGE_LENGTH];
        va_list ap;
        va_start(ap, format);
        vsnprintf(buffer, MAX_LOG_MESSAGE_LENGTH, format, ap);
        va_end(ap);

        //将缓冲区转换为Java字符串
        jstring message = env->NewStringUTF(buffer);

        //如果字符串构造正确
        if (nullptr != message) {

            //记录消息
            env->CallVoidMethod(obj, methodId, message);

            //释放消息引用
            env->DeleteGlobalRef(message);
        }
    }
}

/**
 * 用给定的异常类和异常消息抛出新的异常
 * @param env
 * @param className
 * @param message
 */
static void ThrowException(JNIEnv *env,
                           const char *className, const char *message) {
    jclass clazz = env->FindClass(className);
    if (nullptr != clazz) {
        env->ThrowNew(clazz, message);
    }
}


/**
 * 用给定异常和基于错误号的错误消息抛出新的异常
 * @param env
 * @param className
 * @param errnum
 */
static void ThrowErrnoException(JNIEnv *env, const char *className,
                                int errnum) {

    char buffer[MAX_LOG_MESSAGE_LENGTH];

    //获取错误号信息
    if (-1 == strerror_r(errnum, buffer, MAX_LOG_MESSAGE_LENGTH)) {

        strerror_r(errno, buffer, MAX_LOG_MESSAGE_LENGTH);
    }

    //抛出异常
    ThrowException(env, className, buffer);
}

/**
 * 构造新的TCP socket.
 * @param env
 * @param obj
 * @return
 */
static int NewTcpSocket(JNIEnv *env, jobject obj) {
    LogMessage(env, obj, "Constructing a new TCP socket...");
    int tcpSocket = socket(PF_INET, SOCK_STREAM, 0);
    // 创建错误的化，句柄会返回-1
    if (-1 == tcpSocket) {
        ThrowErrnoException(env, "java/io/IOException", errno);
    }
    return tcpSocket;
}

/**
 * todo 在调用该函数的方法里extern c
 * 将socket 绑定到某一端口号
 * @param env
 * @param jobject
 * @param sd
 * @param port
 */

static void BindSocketToPort(JNIEnv *env, jobject obj,
                             int sd, unsigned short port) {
    struct sockaddr_in address;
    //绑定socket的地址
    memset(&address, 0, sizeof(address));
    address.sin_family = PF_INET;

    //绑定到所有地址
    address.sin_addr.s_addr = htonl(INADDR_ANY);//htonl本地字节序，转换为网络字节序

    //端口转换为网络字节序
    address.sin_port = htons(port);

    //绑定socket
    LogMessage(env, obj, "Binding to port %hu.", port);
    if (-1 == bind(sd, (struct sockaddr *) &address, sizeof(address))) {

        ThrowErrnoException(env, "java/io/IOException", errno);
    }
};

/**
 * 获取当前绑定的端口号
 * @param env
 * @param obj
 * @param sd
 * @return
 */
static unsigned short GetSocketPort(JNIEnv *env, jobject obj, int sd) {

    unsigned short port = 0;
    struct sockaddr_in address;
    socklen_t addressLength = sizeof(address);
    //获取socket地址
    if (-1 == getsockname(sd, (struct sockaddr *) &address, &addressLength)) {

        ThrowErrnoException(env, "java/io/IOException", errno);
    } else {
        //将端口转换为本机字节序
        port = ntohs(address.sin_port);
        LogMessage(env, obj, "Bind to random port &hu.", port);
    }
}

/**
 * 监听指定的待处理连接的backlog的socket,当backlog 已满时，拒绝新的连接。
 *
 * @param env
 * @param obj
 * @param sd  sd socket descriptor
 * @param backlog  backlog size
 */
static void ListenOnSocket(JNIEnv *env, jobject obj, int sd, int backlog) {

    LogMessage(env, obj, "Listenning on socket with a backlog of %d pending connections.");
    if (-1 == listen(sd, backlog)) {
        ThrowErrnoException(env, "java/io/IOException", errno);
    }
}
/**
 * 记录给定地址的IP地址和端口号
 * @param env
 * @param obj
 * @param message
 * @param address
 */
static void LogAddress(JNIEnv *env, jobject obj,
                       const char *message, const struct sockaddr_in *address) {
    char ip[INET_ADDRSTRLEN];
    //将ip地址转换为字符串
    if (nullptr == inet_ntop(PF_INET, &(address->sin_addr), ip, INET_ADDRSTRLEN)) {
        ThrowErrnoException(env, "java/io/IOException", errno);
    }
}

/**
 * 在给定的socket 上阻塞和等待进来的客户连接
 * @param env
 * @param obj
 * @param sd
 * @return
 */
static int AcceptOnSocket(JNIEnv *env,jobject obj,int sd){
    struct sockaddr_in address;
    socklen_t  addressLength=sizeof(address);

    //阻塞和等待进来的客户端连接
    //并接受它
    LogMessage(env,obj,"Waition for a client connection...");

    int clientSocket = accept(sd,(struct sockaddr*)&address,&addressLength);

    //如果客户socket无效
    if(-1==clientSocket){
        ThrowErrnoException(env, "java/io/IOException", errno);
    }else{
        //记录地址
        LogAddress(env,obj,"Client connection from",&address);
    }
    return clientSocket;
};

/**
 * 阻塞并接收来自socket 的数据放到缓冲区
 * @param env
 * @param obj
 * @param sd
 * @param buffer
 * @param bufferSize
 * @return
 */
static ssize_t ReceiveFromSocket(JNIEnv *env,jobject obj,
                                 int sd,char *buffer,size_t bufferSize){
    LogMessage(env,obj,"Receiving from the socket...");
    ssize_t recvSize = recv(sd,buffer,bufferSize-1,0);

    //如果接收失败
    if(-1==recvSize){
        ThrowErrnoException(env, "java/io/IOException", errno);
    }else{
        //以NULL结尾形成一个字符串
        buffer[recvSize]= NULL;

        //如果数据接收成功
        if(recvSize>0){
            LogMessage(env,obj,"Received %d bytes %s",recvSize,buffer);
        }else{
            LogMessage(env,obj,"Client disconnected.");
        }

    }
    return recvSize;
}

/**
 * 将数据缓冲区发送到socket
 * @param env
 * @param obj
 * @param sd
 * @param buffer
 * @param bufferSize
 * @return
 */
static ssize_t SendToSocket(JNIEnv *env,jobject obj,int sd,
                            const char* buffer,size_t bufferSize){
    LogMessage(env,obj,"Sending to the socket...");
    ssize_t sendSize = send(sd,buffer,bufferSize,0);
    if(-1==sendSize){
        ThrowErrnoException(env, "java/io/IOException", errno);
    }else{
        //如果数据接收成功
        if(sendSize>0){
            LogMessage(env,obj,"Sent %d bytes %s",sendSize,buffer);
        }else{
            LogMessage(env,obj,"Client disconnected.");
        }

    }
    return sendSize;
}


/**
 *
 * @param env
 * @param obj
 * @param sd
 * @param ip
 * @param port
 */
static void ConnectToAddress(JNIEnv *env,jobject obj,int sd,
        const char* ip,unsigned short port){
    LogMessage(env,obj,"Connecting to %s:%uh...",ip,port);
    struct sockaddr_in address;
    memset(&address,0,sizeof(address));
    address.sin_family =PF_INET;
    //将IP地址字符串转换为网络地址
    if(0==inet_aton(ip,&(address.sin_addr))){
        //抛出带错误号的异常
        ThrowErrnoException(env,"java/io/IOException",errno);
    }else{
        //将端口号转换为网络字节顺序
        address.sin_port=htons(port);
        //转换为地址
        if(-1==connect(sd,(const sockaddr *)&address,
                sizeof(address))){
            //抛出带错误的异常
            ThrowErrnoException(env,"java/io/IOException",errno);
        }else{
            LogMessage(env,obj,"Connected");
        }
    }
}

/*
 * Class:     com_jingju_jnitest_Echo
 * Method:    nativeStartUpServer
 * Signature: (I)V
 */
JNIEXPORT void JNICALL Java_com_jingju_jnitest_Echo_nativeStartUpServer
  (JNIEnv *env, jobject obj, jint port){
    //构造新的TCP socket
    int serverSocket=NewTcpSocket(env,obj);
    //上面的方法
    if(nullptr == env->ExceptionOccurred()){
        //将socket绑定到某个端口号
        BindSocketToPort(env,obj,serverSocket,(unsigned short)port);
        if(NULL!=env->ExceptionOccurred()){
            goto exit;
        }

        //如果请求了随机的端口号
        if(0==port){
            //获取当前绑定的端口好socket
            GetSocketPort(env,obj,serverSocket);
            if(nullptr!=env->ExceptionOccurred()){
                goto exit;
            }
        }

        //监听有4个等待连接的backlog的socket
        if(nullptr !=env->ExceptionOccurred()){
            goto exit;
        }

        //接受socket的一个客户连接
        int clientSocket = AcceptOnSocket(env,obj,serverSocket);
        if(nullptr!=env->ExceptionOccurred()){
            goto exit;
        }

        char buffer[MAX_BUFFER_SIZE];
        ssize_t recvSize;
        ssize_t sentSize;

        while(1){
            //从 socket 中接收
            recvSize=ReceiveFromSocket(env,obj,clientSocket,buffer,MAX_BUFFER_SIZE);
            if((0==recvSize) || (nullptr!=env->ExceptionOccurred())){
                break;
            }

            //发送给socket
            sentSize=SendToSocket(env,obj,clientSocket,buffer,(size_t)recvSize);

            if((0==sentSize) || (nullptr != env->ExceptionOccurred())){
                break;
            }
        }
        //关闭客户端
        close(clientSocket);
    }
   exit:
    if(serverSocket>0){
        close(serverSocket);
    }

}

/*
 * Class:     com_jingju_jnitest_Echo
 * Method:    nativeStartTcpClient
 * Signature: (Ljava/lang/String;ILjava/lang/String;)V
 */
JNIEXPORT void JNICALL Java_com_jingju_jnitest_Echo_nativeStartTcpClient
        (JNIEnv *env, jobject obj, jstring ip, jint port, jstring message){
    //构造新的TCP socket
    int clientSocket=NewTcpSocket(env,obj);
    if(nullptr == env->ExceptionOccurred()){
        //以 C 字符串形式获取IP地址
        const char* ipAddress = env->GetStringUTFChars(ip,NULL);
        if(nullptr==ipAddress){
            goto exit;
        }
        //连接到IP地址和端口号
        ConnectToAddress(env,obj,clientSocket,ipAddress,(unsigned  short)port);
        //释放IP地址
        env->ReleaseStringUTFChars(ip,ipAddress);
        //如果连接成功
        if(nullptr!=env->ExceptionOccurred()){
            goto exit;
        }

        //以C字符串形式获取消息
        const char * messageText = env->GetStringUTFChars(message, nullptr);
        if(nullptr==messageText){
            goto exit;
        }
        //获取消息大小

        jsize messageSize=env->GetStringUTFLength(message);

        //发送消息给socket
        SendToSocket(env,obj,clientSocket,messageText,messageSize);
        //释放消息文本
        env->ReleaseStringUTFChars(message,messageText);
        //如果未发送成功
        if(nullptr!=env->ExceptionOccurred()){
            goto exit;
        }
        char buffer[MAX_BUFFER_SIZE];

        //从socket接收
        ReceiveFromSocket(env,obj,clientSocket,buffer,MAX_BUFFER_SIZE);
    }


    exit:
    if(clientSocket>-1){
        close(clientSocket);
    }

}


#ifdef __cplusplus
}
#endif
#endif
