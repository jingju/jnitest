/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jingju_jnitest_Threads */

#ifndef _Included_com_jingju_jnitest_Threads
#define _Included_com_jingju_jnitest_Threads
#ifdef __cplusplus
extern "C" {
#endif
#include<stdio.h>
#include <unistd.h>
#include <pthread.h>


struct NativeWorkerArgs {
    jint id;
    jint iterations;
};

// 缓存方法Id
static jmethodID gOnNativeMessage = nullptr;

static JavaVM *gVm = nullptr;//虚拟机的一个引用

static jobject gObj = nullptr;//java对象的一个引用

static pthread_mutex_t mutex;//互斥量
static void throwRuntimeException(JNIEnv * env,char * message){
    jclass exceptionClazz = env->FindClass("java/lang/RuntimeException");
    env->ThrowNew(exceptionClazz, message);
}
static void nativeWorker(JNIEnv *env, jobject obj, jint id, jint iterations) {
    for (jint i = 0; i < iterations; i++) {
        char message[26];
        sprintf(message, "worker %d : iteration %d", id, i);
        jstring messageString = env->NewStringUTF(message);

        env->CallVoidMethod(obj, gOnNativeMessage, messageString);
        if (nullptr != env->ExceptionOccurred()) {
            break;
        }
        sleep(1);//睡眠1s
    }
}
/**
 * 原生线程使用的方法
 *
 */

static void *nativeWorkerThread(void *args) {
    JNIEnv *env = nullptr;
    /**
     * 将JavaVM附加到当前线程，获取JNIEnv的指针
     */
    if (0 == gVm->AttachCurrentThread(&env, nullptr)) {

        NativeWorkerArgs *nativeWorkerArgs = (NativeWorkerArgs *) args;
        if(0!=pthread_mutex_lock(&mutex)){
            throwRuntimeException(env,"unable to lock mutext");
            return (void *) -1;
        }
        nativeWorker(env, gObj, nativeWorkerArgs->id, nativeWorkerArgs->iterations);

        if(0!=pthread_mutex_unlock(&mutex)){
            throwRuntimeException(env,"unable to unlock mutex");
            return (void *) -1;
        }

        delete nativeWorkerArgs;

        //从虚拟机中分离当前线程
        gVm->DetachCurrentThread();

    }
    return (void *) 1;
}





/*
 * Class:     com_jingju_jnitest_Threads
 * Method:    nativeInit
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_jingju_jnitest_Threads_nativeInit
        (JNIEnv *env, jobject obj) {
    //初始化互斥量
    if(0!=pthread_mutex_init(&mutex,nullptr)){
        jclass exceptionClazz = env->FindClass("java/lang/RuntimeException");
        env->ThrowNew(exceptionClazz, "unable to initialize mutex");
        return;
    }

    if (nullptr == gObj) {//缓存一个java对象的引用到本地
        gObj = env->NewGlobalRef(obj);
        if (nullptr == gObj) {
            return;
        }
    }

    if (nullptr == gOnNativeMessage) {//缓存方法id

        jclass clazz = env->GetObjectClass(obj);

        gOnNativeMessage = env->GetMethodID(clazz, "onNativieMessage", "(Ljava/lang/String;)V");

        if (nullptr == gOnNativeMessage) {//没有找到方法

            jclass exceptionClazz = env->FindClass("java/lang/RuntimeException");
            env->ThrowNew(exceptionClazz, "unable to find method");

        }
    }
}

/*
 * Class:     com_jingju_jnitest_Threads
 * Method:    nativeFree
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_jingju_jnitest_Threads_nativeFree
        (JNIEnv *env, jobject obj) {
    if (nullptr != gObj) {
        env->DeleteGlobalRef(gObj);
        gObj = nullptr;
    }
    //释放互斥量
    if(0!=pthread_mutex_destroy(&mutex)){
        jclass exceptionClazz = env->FindClass("java/lang/RuntimeException");
        env->ThrowNew(exceptionClazz, "unable to destroy mutex");
    }
}

/*
 * Class:     com_jingju_jnitest_Threads
 * Method:    nativeWorker
 * Signature: (II)V
 */
/**
 * 没有使用互斥量的woker
 */
//JNIEXPORT void JNICALL Java_com_jingju_jnitest_Threads_nativeWorker
//        (JNIEnv *env, jobject obj, jint id, jint iterations) {
//
//    nativeWorker(env, obj, id, iterations);
//}
/**
 * 使用互斥量的worker
 * @param env
 * @param obj
 * @param id
 * @param iterations
 */
JNIEXPORT void JNICALL Java_com_jingju_jnitest_Threads_nativeWorker
        (JNIEnv *env, jobject obj, jint id, jint iterations) {

    nativeWorker(env, obj, id, iterations);
}
/**
 * 常规开启pthread代码
 *
 */
//JNIEXPORT void JNICALL Java_com_jingju_jnitest_Threads_posixThreads
//        (JNIEnv *env, jobject obj, jint threads, jint iterations) {
//    for (jint i = 0; i < threads; ++i) {
//        NativeWorkerArgs *nativeWorkerArgs = new NativeWorkerArgs;
//        nativeWorkerArgs->id = i;
//        nativeWorkerArgs->iterations = iterations;
//
//        pthread_t thread;
//
//        int result = pthread_create(&thread, NULL, nativeWorkerThread, (void *) nativeWorkerArgs);
//        if (0 != result) {//0时，创建成功
//                jclass exceptionClazz = env->FindClass("java/lang/RuntimeException");
//                env->ThrowNew(exceptionClazz, "unable to create thread");
//        }
//    }
//
//}
/**
 *  等待线程结束获取返回值
 * @param env
 * @param obj
 * @param threads
 * @param iterations
 */
JNIEXPORT void JNICALL Java_com_jingju_jnitest_Threads_posixThreads
        (JNIEnv *env, jobject obj, jint threads, jint iterations) {

    pthread_t *handles = new pthread_t[threads];//创建了一个线程句柄的数组，可以用new

    for (int i = 0; i < threads; ++i) {
        NativeWorkerArgs *nativeWorkerArgs = new NativeWorkerArgs;
        nativeWorkerArgs->id = i;
        nativeWorkerArgs->iterations = iterations;
        int result = pthread_create(&handles[i], NULL, nativeWorkerThread,
                                    (void *) nativeWorkerArgs);
        if (0 != result) {//0时，创建成功
            jclass exceptionClazz = env->FindClass("java/lang/RuntimeException");
            env->ThrowNew(exceptionClazz, "unable to create thread");
            return;

        }
    }
    void *reusult = nullptr;
    for (jint i = 0; i < threads; ++i) {
        if (0 != pthread_join(handles[i], reinterpret_cast<void **>(&reusult))) {
            jclass exceptionClazz = env->FindClass("java/lang/RuntimeException");
            env->ThrowNew(exceptionClazz, "unable to join thread");
        } else {
            //
            char message[26];
            sprintf(message, "worker %d : returned %d", i, reusult);
            jstring messageString = env->NewStringUTF(message);
            env->CallVoidMethod(obj, gOnNativeMessage, messageString);
            if (nullptr != env->ExceptionOccurred()) {
                return;
            }
        }
    }

}


/**
 * 执行到System.loadLibrary()的时候，会先调用JNI_OnLoad()
 * @param vm
 * @param reserved
 * @return
 */
JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    gVm = vm;
    return JNI_VERSION_1_4;//没有version ,默认是1。1一些先进的功能不能使用
}


#ifdef __cplusplus
}
#endif
#endif
